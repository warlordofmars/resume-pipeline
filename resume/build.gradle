
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import java.util.TimeZone


plugins {
    id "com.github.breadmoirai.github-release" version "2.2.3"
}


githubRelease {
  token getProperty('github.token')
  owner rootProject.gitHubOwner
  repo rootProject.gitHubRepo
  tagName "release-${rootProject.version}"
  releaseName "v${rootProject.version}"
  overwrite true
  releaseAssets file("${buildDir}/resume.pdf") 
}


ext.tests = [

    ensureStringsTest: [resumeSource, 'Expected Strings Found in Deployed HTML Resume'],
    resumeDeployedWebTest: [resumeSource, 'Deployed Resumes Are Web Accessible'],
    resumeDeployedGoogleTest: [resumeSource, 'Resume Deployed to Google Drive'],
    resumeDeployedAppleTest: [resumeSource, 'Resume Deployed to iCloud Drive'],
    
    ensureStringsProdTest: [resumeSource, 'Expected Strings Found in Deployed HTML Resume in Production'],
    resumeDeployedWebProdTest: [resumeSource, 'Deployed Resumes Are Web Accessible in Production'],
    resumeDeployedGoogleProdTest: [resumeSource, 'Resume Deployed to Google Drive in Production'],
    resumeDeployedAppleProdTest: [resumeSource, 'Resume Deployed to iCloud Drive in Production'],
    
    resumeContentAnalysis: [resumeSource, 'Resume Content Analysis'],
    resumeUrlCheckTest: [resumeSource, 'Resume URLs Validation'],
    spellCheckTest: [resumeSource, 'Resume Spell Check'],
    jsonSchemaValidationTest: [resumeSource, 'JSON Resume Schema Validation'],
    jsonSyntaxValidationTest: [resumeSource, 'JSON Syntax Validation']

]

if(System.env.containsKey('PROMOTE')) {
    tests << [
        
    ]
}

def iCloudLocalDir = "${System.env.HOME}/Library/Mobile Documents/com~apple~CloudDocs"


def buildResumeWithTheme(format, theme) {
    exec {
        commandLine 'hackmyresume', 'build', "${buildDir}/${resumeSource}", 'TO', "${buildDir}/resume.${format}", '-t', theme
    }
}

def buildResume(format) {
    exec {
        commandLine 'hackmyresume', 'build', "${buildDir}/${resumeSource}", 'TO', "${buildDir}/resume.${format}"
    }
}

task('validateJson') {
    finalizedBy rootProject.processTestResults
    dependsOn rootProject.registerTests
    doLast {
        try {
            new JsonSlurper().parseText(file(resumeSource).text)
            jsonSyntaxValidationTest.success("Valid JSON!")
        } catch(Exception e) {
            jsonSyntaxValidationTest.failure('JSON Syntax Error', e.toString())
        }
    }
}

task('validateResume') {
    finalizedBy rootProject.processTestResults
    dependsOn validateJson, rootProject.checkPrerequisites, rootProject.registerTests
    doFirst {
        def output = new ByteArrayOutputStream()
        exec {
            commandLine 'hackmyresume', 'validate', resumeSource
            standardOutput output
        }
        if (output.toString().contains('INVALID')) {
            jsonSchemaValidationTest.failure('Validation Vailed', output.toString())
        } else {
            jsonSchemaValidationTest.success(output.toString())
        }
    }
}

task('spellCheck') {
    finalizedBy rootProject.processTestResults
    mustRunAfter validateResume
    dependsOn rootProject.checkPrerequisites, rootProject.registerTests
    doFirst {
        def out = new ByteArrayOutputStream()
        exec {
            commandLine 'aspell', 'list', '-t', '--home-dir=.', "--personal=${spellCheckIgnoreList}"
            standardInput new ByteArrayInputStream(file(resumeSource).text.getBytes())
            standardOutput out
        }
        def errors = out.toString().readLines()
        if (errors.size() > 0) {
            spellCheckTest.failure('Mis-spelled Word', "There were ${errors.size()} words misspelled in ${resumeSource}:\n\n${errors}")
        }
        spellCheckTest.success("No spelling errors detected in ${resumeSource}")
    }
}

task('checkUrls') {
    finalizedBy rootProject.processTestResults
    mustRunAfter validateResume
    dependsOn rootProject.registerTests
    doFirst {
        def URLs = file(resumeSource).text.findAll('http[s]?://[a-zA-Z0-9./-]+')
        URLs.each { detectedURL ->
            try {
                def test = detectedURL.toURL().text
                println "Found the URL ${detectedURL} in ${resumeSource} and it is currently a live link."
                
            } catch(Exception e) {
                resumeUrlCheckTest.failure('Bad URL Found', "Could not connect to the URL: ${detectedURL} \nFound in ${resumeSource}\n\n${e.toString()}")
            }
        }
        resumeUrlCheckTest.success("All URLs found in ${resumeSource} are valid URLs and are currently responding:\n\n${URLs.join('\n')}")
    }
}

task('buildResume') {
    mustRunAfter checkUrls, spellCheck
    doLast {
        def resumeFile = file(resumeSource)
        def resumeLastModified = new Date(resumeFile.lastModified()).format('YYYY-MM-DD\'T\'hh:mm:ss\'Z\'', TimeZone.getTimeZone('GMT'))
        def resumeObj = new JsonSlurper().parseText(resumeFile.text)
        resumeObj['meta'] = [ 
            version: rootProject.version,
            lastModified: resumeLastModified
        ]
        file("${buildDir}").mkdirs()
        file("${buildDir}/${resumeSource}").write(new JsonBuilder(resumeObj).toPrettyString())
        println "Versioning ${resumeSource} to version ${rootProject.version}"

    }
}

resumeFormats.each { format ->
    task("build${format.capitalize()}Resume") {
        dependsOn buildResume
        mustRunAfter validateResume, spellCheck, checkUrls
        doFirst {
            if (rootProject.hasProperty("${format}ResumeTheme")) {
                buildResumeWithTheme(format, rootProject.getProperty("${format}ResumeTheme"))
            } else {
                buildResume(format)
            }
        }
    }
}

task('analyzeResume') {
    finalizedBy rootProject.processTestResults
    dependsOn rootProject.registerTests, rootProject.checkPrerequisites
    mustRunAfter validateResume, spellCheck, buildHtmlResume
    doFirst {
        try {
            def out = new ByteArrayOutputStream()
            exec {
                commandLine 'hackmyresume', 'analyze', resumeSource
                standardOutput out
            }
            def report = out.toString()
            file(buildDir).mkdirs()
            file("${buildDir}/resume-analysis.txt").text = report
            resumeContentAnalysis.success(report)
        } catch(Exception e) {
            resumeContentAnalysis.failure('Error Generating Report', e.toString())
        }
    }
}

task('clean', type:Delete) {
    delete buildDir
}

task('build') {
    dependsOn validateResume, spellCheck, checkUrls, analyzeResume
    
}

build.dependsOn {
    project.tasks.findAll {
        it.name ==~ /build.*Resume/
    }
}

task('print') {
    mustRunAfter build
    dependsOn rootProject.checkPrerequisites
    doFirst {
        exec {
            commandLine 'lp', '-n', getNumberOfCopies(), '-o', 'fit-to-page', '-o', 'sides=two-sided-long-edge', '-o', 'media=letter', "${buildDir}/resume.pdf"
        }
    }
}

task('printPreview') {
    dependsOn buildPdfResume
    doFirst {
        exec {
            commandLine 'open', "${buildDir}/resume.pdf"
        }
    }
}

task('publishResumeToWeb') {
    mustRunAfter build
    dependsOn ':website:deploy', rootProject.checkPrerequisites
    doFirst {

        exec {
            commandLine 'aws', 's3', 'cp', "${buildDir}/resume.html", "s3://${getWebsiteUrl()}${getPrefix()}/index.html"
        }

        exec {
            commandLine 'aws', 's3', 'cp', "${buildDir}/resume-analysis.txt", "s3://${getWebsiteUrl()}${getPrefix()}/"
        }

        resumeFormats.each { format ->
            exec {
                commandLine 'aws', 's3', 'cp', "${buildDir}/resume.${format}", "s3://${getWebsiteUrl()}${getPrefix()}/resume.${format}"
            }
        }
    }
}

task('publishResumeToGoogle') {
    mustRunAfter build
    dependsOn rootProject.checkPrerequisites
    doLast {

        def out = new ByteArrayOutputStream()
        exec {
            commandLine 'gdrive', 'list', '--no-header', '-q', "name = 'resume.v${rootProject.version}.pdf'"
            standardOutput out
        }

        out.toString().readLines().each {
            def fileId = it.split(" ")[0]
            exec {
                commandLine 'gdrive', 'delete', fileId
            }
        }

        exec {
            commandLine 'gdrive', 'upload', '--name', "resume.v${rootProject.version}.pdf", "${buildDir}/resume.pdf"
        }

        if(System.env.containsKey('PROMOTE')) {
            def out2 = new ByteArrayOutputStream()
            exec {
                commandLine 'gdrive', 'list', '--no-header', '-q', 'name = "resume.pdf"'
                standardOutput out2
            }
            def fileId = out2.toString().split(" ")[0]
            exec {
                commandLine 'gdrive', 'update', fileId, "${buildDir}/resume.pdf"
            }
        }
    }
}

task('publishResumeToApple') {
    mustRunAfter build
    dependsOn rootProject.checkPrerequisites
    doLast {
        exec {
            commandLine 'cp', "${buildDir}/resume.pdf", "${iCloudLocalDir}/resume.v${rootProject.version}.pdf"
        }
        if(System.env.containsKey('PROMOTE')) {
            exec {
                commandLine 'cp', "${buildDir}/resume.pdf", "${iCloudLocalDir}/resume.pdf"
            }
        }
    }
}

task('postDeployCheck') {
    finalizedBy rootProject.processTestResults
    mustRunAfter publishResumeToWeb, publishResumeToGoogle, publishResumeToApple
    dependsOn rootProject.registerTests
    doFirst {

        def ensureStringsTestObj = rootProject.ensureStringsTest
        def resumeDeployedWebTestObj = resumeDeployedWebTest
        def resumeDeployedGoogleTestObj = resumeDeployedGoogleTest
        def resumeDeployedAppleTestObj = resumeDeployedAppleTest

        if(System.env.containsKey('PROMOTE')) {
            ensureStringsTestObj = rootProject.ensureStringsProdTest
            resumeDeployedWebTestObj = resumeDeployedWebProdTest
            resumeDeployedGoogleTestObj = resumeDeployedGoogleProdTest
            resumeDeployedAppleTestObj = resumeDeployedAppleProdTest
        }
        
        def deployURL = "https://${getWebsiteUrl()}${getPrefix()}/"
        def content = deployURL.toURL().text
        
        ensureStrings.each { word ->
            if (!content.contains(word)) {
                ensureStringsTestObj.failure('Expected String Not Found', "The ensure string \"${word}\" was not found in ${deployURL}")
            }
        }
        ensureStringsTestObj.success("Found all expected strings in deployed HTML resume at ${deployURL}:\n\n${ensureStrings.join('\n')}")
        
        def urlList = []
        resumeFormats.each { format ->
            def url = "https://${getWebsiteUrl()}${getPrefix()}/resume.${format}"
            try {
                def test = url.toURL().text
                println "Found deployed ${format} resume at ${url}"                
                urlList << url
            } catch(Exception e) {
                resumeDeployedWebTestObj.failure('Deployed Resume Not Accessible', "The ${format} version of the resume could not be found at the deployed URL of ${url}\n\n${e.toString()}")
            }
        }
        resumeDeployedWebTestObj.success("All resume formats have been deployed successfully and are currently web-accessible at the following URLs:\n\n${urlList.join('\n')}")

        def out = new ByteArrayOutputStream()
        exec {
            commandLine 'gdrive', 'list', '--no-header', '-q', "name = 'resume.v${rootProject.version}.pdf'"
            standardOutput out
        }

        if(out.toString().split(" ").size() > 1) {
            resumeDeployedGoogleTestObj.success("resume.v${rootProject.version}.pdf is available in Google Drive")
        } else {
            resumeDeployedGoogleTestObj.failure('Resume Not Found in Google Drive', "resume.v${rootProject.version}.pdf is not found in Google Drive")
        }


        if(file("${iCloudLocalDir}/resume.v${rootProject.version}.pdf").exists()) {
            resumeDeployedAppleTestObj.success("resume.v${rootProject.version}.pdf is available in iCloud Drive")
        } else {
            resumeDeployedAppleTestObj.failure('File Not Found', "resume.v${rootProject.version}.pdf was not found in iCloud Drive")
        }
        
    }
}

task('deploy') {
    dependsOn publishResumeToWeb, publishResumeToApple, publishResumeToGoogle, postDeployCheck    
    if(System.env.containsKey('PROMOTE')) {
        dependsOn tasks['githubRelease']
    }
}

tasks['githubRelease'].mustRunAfter build
