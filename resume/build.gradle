
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import java.util.TimeZone

def buildResumeWithTheme(format, theme) {
    exec {
        commandLine 'hackmyresume', 'build', "${buildDir}/${resumeSource}", 'TO', "${buildDir}/resume.${format}", '-t', theme
    }
}

def buildResume(format) {
    exec {
        commandLine 'hackmyresume', 'build', "${buildDir}/${resumeSource}", 'TO', "${buildDir}/resume.${format}"
    }
}

task('validateJson') {
    finalizedBy rootProject.processTestResults
    dependsOn rootProject.registerTests
    doLast {
        try {
            new JsonSlurper().parseText(file(resumeSource).text)
            jsonSyntaxValidationTest.success("Valid JSON!")
        } catch(Exception e) {
            jsonSyntaxValidationTest.failure('JSON Syntax Error', e.toString())
            throw new GradleException("JSON Syntax Error in ${resumeSource}:\n\n${e.toString()}")
        }
    }
}

task('validateResume') {
    finalizedBy rootProject.processTestResults
    dependsOn validateJson, rootProject.checkPrerequisites, rootProject.registerTests
    doFirst {
        def output = new ByteArrayOutputStream()
        exec {
            commandLine 'hackmyresume', 'validate', resumeSource
            standardOutput output
        }
        if (output.toString().contains('INVALID')) {
            jsonSchemaValidationTest.failure('Validation Vailed', output.toString())
            throw new GradleException("Resume validation has failed:\n\n${output.toString()}")
        } else {
            println output.toString()
            jsonSchemaValidationTest.success(output.toString())
        }
    }
}

task('spellCheck') {
    finalizedBy rootProject.processTestResults
    mustRunAfter validateResume
    dependsOn rootProject.checkPrerequisites, rootProject.registerTests
    doFirst {
        def out = new ByteArrayOutputStream()
        exec {
            commandLine 'aspell', 'list', '-t', '--home-dir=.', "--personal=${spellCheckIgnoreList}"
            standardInput new ByteArrayInputStream(file(resumeSource).text.getBytes())
            standardOutput out
        }
        def errors = out.toString().readLines()
        if (errors.size() > 0) {
            def message = "There were ${errors.size()} words misspelled in ${resumeSource}:\n\n${errors}"
            spellCheckTest.failure('Mis-spelled Word', message)
            throw new GradleException(message)
        }
        def message = "No spelling errors detected in ${resumeSource}"
        spellCheckTest.success(message)
        print message
    }
}

task('checkUrls') {
    finalizedBy rootProject.processTestResults
    mustRunAfter validateResume
    dependsOn rootProject.registerTests
    doFirst {
        def URLs = file(resumeSource).text.findAll('http[s]?://[a-zA-Z0-9./-]+')
        URLs.each { detectedURL ->
            try {
                def test = detectedURL.toURL().text
                println "Found the URL ${detectedURL} in ${resumeSource} and it is currently a live link."
                
            } catch(Exception e) {
                def message = "Could not connect to the URL: ${detectedURL} \nFound in ${resumeSource}\n\n${e.toString()}"
                resumeUrlCheckTest.failure('Bad URL Found', message)
                throw new GradleException(message)
            }
        }
        resumeUrlCheckTest.success("All URLs found in ${resumeSource} are valid URLs and are currently responding:\n\n${URLs.join('\n')}")
    }
}


task('buildResume') {
    mustRunAfter checkUrls, spellCheck
    doLast {
        def resumeFile = file(resumeSource)
        def resumeLastModified = new Date(resumeFile.lastModified()).format('YYYY-MM-DD\'T\'hh:mm:ss\'Z\'', TimeZone.getTimeZone('GMT'))
        def resumeObj = new JsonSlurper().parseText(resumeFile.text)
        resumeObj['meta'] = [ 
            version: rootProject.version,
            lastModified: resumeLastModified
        ]
        file("${buildDir}").mkdirs()
        file("${buildDir}/${resumeSource}").write(new JsonBuilder(resumeObj).toPrettyString())
        println "Versioning ${resumeSource} to version ${rootProject.version}"

    }
}

resumeFormats.each { format ->
    task("build${format.capitalize()}Resume") {
        dependsOn buildResume
        mustRunAfter validateResume, spellCheck, checkUrls
        doFirst {
            if (rootProject.hasProperty("${format}ResumeTheme")) {
                buildResumeWithTheme(format, rootProject.getProperty("${format}ResumeTheme"))
            } else {
                buildResume(format)
            }
        }
    }
}

task('analyzeResume') {
    finalizedBy rootProject.processTestResults
    dependsOn rootProject.registerTests, rootProject.checkPrerequisites
    mustRunAfter validateResume, spellCheck, buildHtmlResume
    doFirst {
        try {
            def out = new ByteArrayOutputStream()
            exec {
                commandLine 'hackmyresume', 'analyze', resumeSource
                standardOutput out
            }
            def report = out.toString()
            file(buildDir).mkdirs()
            file("${buildDir}/resume-analysis.txt").text = report
            println report
            resumeContentAnalysis.success(report)
        } catch(Exception e) {
            resumeContentAnalysis.failure('Error Generating Report', e.toString())
            throw new GradleException(e.toString())
        }
    }
}

task('clean', type:Delete) {
    delete buildDir
}

task('build') {
    dependsOn validateResume, spellCheck, checkUrls, analyzeResume
    
}

build.dependsOn {
    project.tasks.findAll {
        it.name ==~ /build.*Resume/
    }
}

task('print') {
    mustRunAfter build
    dependsOn rootProject.checkPrerequisites
    doFirst {
        exec {
            commandLine 'lp', '-n', getNumberOfCopies(), '-o', 'fit-to-page', '-o', 'sides=two-sided-long-edge', '-o', 'media=letter', "${buildDir}/resume.pdf"
        }
    }
}

task('printPreview') {
    dependsOn buildPdfResume
    doFirst {
        exec {
            commandLine 'open', "${buildDir}/resume.pdf"
        }
    }
}

task('publishResume') {
    finalizedBy rootProject.processTestResults
    mustRunAfter build
    dependsOn ':website:deploy', rootProject.checkPrerequisites
    doFirst {

        exec {
            commandLine 'aws', 's3', 'cp', "${buildDir}/resume.html", "s3://${getWebsiteUrl()}/${getHtmlResumeName()}"
        }

        exec {
            commandLine 'aws', 's3', 'cp', "${buildDir}/resume-analysis.txt", "s3://${getWebsiteUrl()}/"
        }

        resumeFormats.each { format ->
            exec {
                commandLine 'aws', 's3', 'cp', "${buildDir}/resume.${format}", "s3://${getWebsiteUrl()}/resume.${format}"
            }
        }
    }
}


task('postDeployCheck') {
    finalizedBy rootProject.processTestResults
    mustRunAfter publishResume
    dependsOn rootProject.registerTests
    doFirst {
        def deployURL = "https://${getWebsiteUrl()}/${getHtmlResumeName()}"
        def content = deployURL.toURL().text
        ensureStrings.each { word ->
            if (!content.contains(word)) {
                def message = "The ensure string \"${word}\" was not found in ${deployURL}"
                ensureStringsTest.failure('Expected String Not Found', message)
                throw new GradleException(message)
            }
        }
        ensureStringsTest.success("Found all expected strings in deployed HTML resume at ${deployURL}:\n\n${ensureStrings.join('\n')}")
        def urlList = []
        resumeFormats.each { format ->
            def url = "https://${getWebsiteUrl()}/resume.${format}"
            try {
                def test = url.toURL().text
                println "Found deployed ${format} resume at ${url}"                
                urlList << url
            } catch(Exception e) {
                def message = "The ${format} version of the resume could not be found at the deployed URL of ${url}\n\n${e.toString()}"
                deployedResumeTest.failure('Deployed Resume Not Accessible', message)
                throw new GradleException(message)
            }
        }
        def message = "All resume formats have been deployed successfully and are currently web-accessible at the following URLs:\n\n${urlList.join('\n')}"

        deployedResumeTest.success(message)
        println "\nThe resume is confirmed to be published to ${deployURL} successfully, and can now be accessed at that URL.\n\nThe resume contains the following key strings we were looking for:\n\n${ensureStrings}\n"
    }
}

task('deploy') {
    dependsOn publishResume, postDeployCheck
}

ext.tests = [

    ensureStringsTest: [resumeSource, 'Expected Strings Found in Deployed HTML Resume', 'deploy'],
    deployedResumeTest: [resumeSource, 'Deployed Resumes Are Web Accessible', 'deploy'],
    resumeContentAnalysis: [resumeSource, 'Resume Content Analysis', 'build'],
    resumeUrlCheckTest: [resumeSource, 'Resume URLs Validation', 'build'],
    spellCheckTest: [resumeSource, 'Resume Spell Check', 'build'],
    jsonSchemaValidationTest: [resumeSource, 'JSON Resume Schema Validation', 'build'],
    jsonSyntaxValidationTest: [resumeSource, 'JSON Syntax Validation', 'build']
]