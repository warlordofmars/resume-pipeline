
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import java.util.TimeZone

def buildResumeWithTheme(format, theme) {
    exec {
        commandLine 'hackmyresume', 'build', "${buildDir}/${resumeSource}", 'TO', "${buildDir}/resume.${format}", '-t', theme
    }
}

def buildResume(format) {
    exec {
        commandLine 'hackmyresume', 'build', "${buildDir}/${resumeSource}", 'TO', "${buildDir}/resume.${format}"
    }
}

task('validateResume') {
    finalizedBy rootProject.processTestResults
    dependsOn rootProject.checkPrerequisites
    doFirst {
        def output = new ByteArrayOutputStream()
        exec {
            commandLine 'hackmyresume', 'validate', resumeSource
            standardOutput output
        }
        if (output.toString().contains('INVALID')) {
            rootProject.ext.testResults << [classname: resumeSource, name: "JSON Resume Schema Validation", failure: [type: 'Validation Vailed', details: output.toString()]]
            throw new GradleException("Resume validation has failed:\n\n${output.toString()}")
        } else {
            println output.toString()
            rootProject.ext.testResults << [classname: resumeSource, name: "JSON Resume Schema Validation", systemOut: output.toString()]
        }
    }
}

task('spellCheck') {
    finalizedBy rootProject.processTestResults
    mustRunAfter validateResume
    dependsOn rootProject.checkPrerequisites
    doFirst {
        def out = new ByteArrayOutputStream()
        exec {
            commandLine 'aspell', 'list', '-t', '--home-dir=.', "--personal=${spellCheckIgnoreList}"
            standardInput new ByteArrayInputStream(file(resumeSource).text.getBytes())
            standardOutput out
        }
        def errors = out.toString().readLines()
        if (errors.size() > 0) {
            def message = "There were ${errors.size()} words misspelled in ${resumeSource}:\n\n${errors}"
            rootProject.ext.testResults << [classname: resumeSource, name: 'Resume Spell Check', failure: [type: 'Mis-spelled Word', details: message]]
            throw new GradleException(message)
        }
        def message = "No spelling errors detected in ${resumeSource}"
        rootProject.ext.testResults << [classname: resumeSource, name: 'Resume Spell Check', systemOut: message]
        print message
    }
}

task('checkUrls') {
    finalizedBy rootProject.processTestResults
    mustRunAfter validateResume
    doFirst {
        def URLs = file(resumeSource).text.findAll('http[s]?://[a-zA-Z0-9./-]+')
        URLs.each { detectedURL ->
            try {
                def test = detectedURL.toURL().text
                println "Found the URL ${detectedURL} in ${resumeSource} and it is currently a live link."
                
            } catch(Exception e) {
                def message = "Could not connect to the URL: ${detectedURL} \nFound in ${resumeSource}\n\n${e.toString()}"
                rootProject.ext.testResults << [classname: resumeSource, name: "Resume URLs Validation", failure: [type: 'Bad URL Found', details: message]]
                throw new GradleException(message)
            }
        }
        rootProject.ext.testResults << [classname: resumeSource, name: "Resume URLs Validation", systemOut: "All URLs found in ${resumeSource} are valid URLs and are currently responding:\n\n${URLs.join('\n')}"]
    }
}


task('buildResume') {
    mustRunAfter checkUrls, spellCheck
    doLast {
        def resumeFile = file(resumeSource)
        def resumeLastModified = new Date(resumeFile.lastModified()).format('YYYY-MM-DD\'T\'hh:mm:ss\'Z\'', TimeZone.getTimeZone('GMT'))
        def resumeObj = new JsonSlurper().parseText(resumeFile.text)
        resumeObj['meta'] = [ 
            version: rootProject.version,
            lastModified: resumeLastModified
        ]
        file("${buildDir}").mkdirs()
        file("${buildDir}/${resumeSource}").write(new JsonBuilder(resumeObj).toPrettyString())
        println "Versioning ${resumeSource} to version ${rootProject.version}"

    }
}

resumeFormats.each { format ->
    task("build${format.capitalize()}Resume") {
        dependsOn buildResume
        mustRunAfter validateResume, spellCheck, checkUrls
        doFirst {
            if (rootProject.hasProperty("${format}ResumeTheme")) {
                buildResumeWithTheme(format, rootProject.getProperty("${format}ResumeTheme"))
            } else {
                buildResume(format)
            }
        }
    }
}

task('analyzeResume') {
    finalizedBy rootProject.processTestResults
    dependsOn rootProject.checkPrerequisites
    mustRunAfter validateResume, spellCheck, buildHtmlResume
    doFirst {
        def out = new ByteArrayOutputStream()
        exec {
            commandLine 'hackmyresume', 'analyze', resumeSource
            standardOutput out
        }
        def report = out.toString()
        file(buildDir).mkdirs()
        file("${buildDir}/resume-analysis.txt").text = report
        println report
        rootProject.ext.testResults << [classname: resumeSource, name: 'Resume Content Analysis', systemOut: report]
    }
}

task('clean', type:Delete) {
    delete buildDir
}

task('build') {
    dependsOn validateResume, spellCheck, checkUrls, analyzeResume
    
}

build.dependsOn {
    project.tasks.findAll {
        it.name ==~ /build.*Resume/
    }
}

task('print') {
    mustRunAfter build
    dependsOn rootProject.checkPrerequisites
    doFirst {
        exec {
            commandLine 'lp', '-n', getNumberOfCopies(), '-o', 'fit-to-page', '-o', 'sides=two-sided-long-edge', '-o', 'media=letter', "${buildDir}/resume.pdf"
        }
    }
}

task('printPreview') {
    dependsOn buildPdfResume
    doFirst {
        exec {
            commandLine 'open', "${buildDir}/resume.pdf"
        }
    }
}

task('publishResume') {
    finalizedBy rootProject.processTestResults
    mustRunAfter build
    dependsOn ':website:deploy', rootProject.checkPrerequisites
    doFirst {

        exec {
            commandLine 'aws', 's3', 'cp', "${buildDir}/resume.html", "s3://${getWebsiteUrl()}/${getHtmlResumeName()}"
        }

        exec {
            commandLine 'aws', 's3', 'cp', "${buildDir}/resume-analysis.txt", "s3://${getWebsiteUrl()}/"
        }

        resumeFormats.each { format ->
            exec {
                commandLine 'aws', 's3', 'cp', "${buildDir}/resume.${format}", "s3://${getWebsiteUrl()}/resume.${format}"
            }
        }
    }
}


task('postDeployCheck') {
    finalizedBy rootProject.processTestResults
    mustRunAfter publishResume
    doFirst {
        def deployURL = "https://${getWebsiteUrl()}/${getHtmlResumeName()}"
        def content = deployURL.toURL().text
        ensureStrings.each { word ->
            if (!content.contains(word)) {
                def message = "The ensure string \"${word}\" was not found in ${deployURL}"
                rootProject.ext.testResults << [classname: resumeSource, name: 'Expected Strings Found in Deployed HTML Resume', failure: [type: 'Expected String Not Found', details: message]]
                throw new GradleException(message)
            }
        }
        rootProject.ext.testResults << [classname: resumeSource, name: 'Expected Strings Found in Deployed HTML Resume', systemOut: "Found all expected strings in deployed HTML resume at ${deployURL}:\n\n${ensureStrings.join('\n')}"]
        def urlList = []
        resumeFormats.each { format ->
            def url = "https://${getWebsiteUrl()}/resume.${format}"
            try {
                def test = url.toURL().text
                println "Found deployed ${format} resume at ${url}"                
                urlList << url
            } catch(Exception e) {
                def message = "The ${format} version of the resume could not be found at the deployed URL of ${url}\n\n${e.toString()}"
                rootProject.ext.testResults << [classname: resumeSource, name: "Deployed Resumes Are Web Accessible", failure: [type: 'Deployed Resume Not Accessible', details: message]]
                throw new GradleException(message)
            }
        }
        def message = "All resume formats have been deployed successfully and are currently web-accessible at the following URLs:\n\n${urlList.join('\n')}"

        rootProject.ext.testResults << [classname: resumeSource, name: "Deployed Resumes Are Web Accessible", systemOut: message]
        println "\nThe resume is confirmed to be published to ${deployURL} successfully, and can now be accessed at that URL.\n\nThe resume contains the following key strings we were looking for:\n\n${ensureStrings}\n"
    }
}

task('deploy') {
    dependsOn publishResume, postDeployCheck
}
